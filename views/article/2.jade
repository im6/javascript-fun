extends generic
block 2
    h3 前言
    p javascript的压缩混淆随处可见，包括uglify、compressor、clouser等。
    p 而uglify带来的好处很多，除了压缩代码体积之外，还可以维持源代码的可读性。
    p
        | 目前社交类网站如FaceBook、微博等，出于保护前端（业务或者技术）逻辑的目的，
        | 生产代码的源码并没有开源。
        | 了解混淆原理可以帮助我们进行代码逻辑的逆推，重塑源代码，学到更多“非开源”的内容。
    p 本篇文章主要是围绕
        b 新浪微博
        | 前端代码为例子，进行逆向读取的
        b 语法分析。
    h2 1. if条件句
    p 当条件执行语句只有一行时，转换为条件赋值语句(conditional/ternary Operator)
    pre
        code.Javascript
            | var s = false;
            | if(s) {
            |     console.log(123);
            | }
            | &nbsp;
            | // after uglification
            | &nbsp;
            | var s=!1;s&&console.log(123);
    pre
        code.Javascript
            | var s = true;
            | if(!s) {
            |     console.log(123);
            | }
            | &nbsp;
            | // after uglification
            | &nbsp;
            | var s=!0;s||console.log(123);
    pre
        code.Javascript
            | var a = true;
            | var b = false;
            | if(!a) {
            |    if(!b) {
            |        console.log(123);
            |    }
            | }
            | &nbsp;
            | // after uglification
            | &nbsp;
            | var a=!0,b=!1;a||b||console.log(123);
    h2 2. 函数
    h3 2.1 函数声明
    p 主要是参数名称的简化。
    pre
        code.Javascript
            | function add(num1, num2) {
            |   return num1 + num2;
            | }
            | &nbsp;
            | // after uglification
            | &nbsp;
            | function add(a,t){return a+t}
    h3 2.2 Self-invoking functions
    p 通过“!”触发函数
    pre
        code.Javascript
            | (function(num1, num2) {
            |    return num1 + num2;
            | })(2,3);
            | &nbsp;
            | // after uglification
            | &nbsp;
            | !function(a,t){return a+t}(2,3);
    h3 2.3 破坏可读性的混淆
    p
        | 这种方式虽然对可读性进行了破坏，但是大多数情况，恢复起来的难度并不大。
    pre
        code.Javascript
            | var a = document.getElementById('a');
            | a.innerHTML = 'hello world';
            | &nbsp;
            | // after uglification
            | &nbsp;
            | (function(a, b, c, d, e, f){
            |     a[d] = a[b][c](d);
            |     a[d][e]=f;
            | })(this, 'document', 'getElementById', 'a', 'innerHTML', 'hello world');

    h2 3. 变量
    h3 3.1 作用域区分
    p 由于压缩需要对现有变量名称进行改写，所以会出现相同的名称出现在不同区域，这时候的结局方案是：
        b “就近原则”
    p 下图例子代码来自weibo.com页面源码。
    pre
        code.Javascript
            | var a = $CONFIG, // a表示变量$CONFIG
            |     b = FM.view;
            | FM.view = function(a) {
            |     a = a || {}; // a表示方程的第一个argument，而不是外面的$CONFIG
            |     return a;
            | }
    h3 3.2 赋值
    p 赋值操作的返回值是等号右边的引用，所以多重引用传递写成一行。
    p 下图例子代码来自weibo.com页面源码。
    pre
        code.Javascript
            | m = k.onerror = k.onload = k.onreadystatechange = function() {
            |     // ... ...
            |     // function body
            |     // ... ...
            | }
    h2 总结
    p 本文主要涉及的是传统JavaScript的逆向读取的几个常见情况，稍后我会更新es2015的加密与混淆。


