<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="keywords" content="javascript.fun javascript beginner npm github node.js"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>Most Popular Javascript Framework 2017 | Everything about JavaScript | JavaScript.fun</title><link rel="shortcut icon" type="image/png" href="//dkny.oss-cn-hangzhou.aliyuncs.com/1/assets/fav.ico"><script type="text/javascript">if(window.location.hostname.indexOf('javascript.fun') > -1){
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q || []).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-79220512-3', 'auto');
    ga('send', 'pageview');
}</script><script type="text/javascript" src="/build/article1.js?dc2"></script></head></html><body><div class="pure-g"><div class="pure-u-1-5 sidebar"><header class="header"><h1 id="sbttl1">JavaScript</h1><h1 id="sbttl2">for</h1><div class="type"></div><nav id="typed-strings"><p>2017</p><p>Developer</p><p>Designer</p><p>Architect</p><p>Beginner</p><p>Fun!</p></nav></header></div><div class="pure-u-4-5 content"><div class="menubar"><div role="group" class="pure-button-group"><a title="Front End Framework" href="/" class="pure-button"><img src="//dkny.oss-cn-hangzhou.aliyuncs.com/1/assets/vue.png"/></a><a title="Node.js Framework" href="/node" class="pure-button"><img src="//dkny.oss-cn-hangzhou.aliyuncs.com/1/assets/mongo.png"/></a><a title="JS Library" href="/library" class="pure-button"><img src="//dkny.oss-cn-hangzhou.aliyuncs.com/1/assets/bower.png"/></a><a title="Tool" href="/site/" class="pure-button"><img src="//dkny.oss-cn-hangzhou.aliyuncs.com/1/assets/site.png"/></a><a title="Article" href="/article/" class="pure-button pure-button-active"><img src="//dkny.oss-cn-hangzhou.aliyuncs.com/1/assets/flight.png"/></a></div></div><article><div class="articleTitle"><p class="time">2017-08-30 13:00:00</p><h1 class="title">Vue/React的加载优化(高级篇)</h1><div class="tag tag_0">Webpack</div><div class="tag tag_1">react</div><div class="tag tag_2">vue</div><div class="tag tag_3">angular</div><div class="tag tag_0">阿里云</div><div class="tag tag_1">OSS</div></div><h2>前言</h2><p>当下，Vue、React和Angular火爆异常。三者的共同点之一，就是都可以借助Webpack构建项目bundle文件。</p><p>本文重点讲述如何减少bundle体积，以及提升页面加载速度。
从Webpack开始，同时讲述如何借助常见云平台和node端提升加载效率。</p><div style="background:#d0d0d0;padding:10px;border-radius:6px;">首先引入一个小问题：<br>请打开本页面的开发窗口（如果是Chrome用户点击F12），在Network标签下发现分别从两个地方下载了vue.js。
这两个文件名称相同，内容相同。一个从CDN加载，一个从OSS加载。可为什么文件尺寸区别这么大？</div><p>(图中浏览器Chrome:Mac Version 60.0.3112.101)</p><div class="pure-g"><div class="pure-u-md-1-1"><img src="//dkny.oss-cn-hangzhou.aliyuncs.com/1/article/4/console.png" class="atcImg"></div></div><script>var script0 = document.createElement('script');
script0.type = "text/javascript";
script0.charset = "utf-8";
script0.src = '//cdn.bootcss.com/vue/2.4.2/vue.js';
document.head.appendChild(script0);

var script1 = document.createElement('script');
script1.type = "text/javascript";
script1.charset = "utf-8";
script1.src = '//dkny.oss-cn-hangzhou.aliyuncs.com/1/article/4/vue.js';
document.head.appendChild(script1);</script><h2>正文说明</h2><p>关于Webpack优化，相关文章说明很多，也很详细。
但是由于版本更替， Webpack v1.x 到 v3.5(2017.08.30)版本差异也造成了一些文章实时性不高。
此外，代码的可达性也十分重要，部署出人人可见的代码，必定是一个从前到后的过程，
只说一端总是不透彻。</p><p> 
所以我就写个“本土化”的总结：过去反复讲述的东西，简单说明；而真正的干货，则详细展开。</p><h2>Webpack中的一般优化</h2><ol><li><h3>提取bundle中图片，用以减少体积。</h3><p>Webpack将图片直接转换为base64格式，使得图片间接存入bundle文件，导致体积过大。</p><p>方法: 图片取消转化而改为引用。缺点是需要额外的时间载入图片。</p></li><li><h3>OccurrenceOrder</h3><p>new webpack.optimize.OccurrenceOrderPlugin()</p><p>打包过程中，最小化id值。在Webpack v2.0以及以后的版本默认添加。</p></li><li><h3>DefinePlugin</h3><p>改变环境变量。</p><p>当NODE_ENV=production后，提升代码打包效果。UglifyJS会将dev模式下的代码清洗掉(如react)。</p></li><li><h3>Dedupe</h3><p>防止代码重复添加。</p><p>在Webpack v2.0以及以后的版本不再需要。</p></li><li><h3>Uglify</h3><p>new webpack.optimize.UglifyJsPlugin([options])</p><p>老生常谈，注意除了UglifyJsPlugin本身的配置之外，uglifyOptions内部也有很多需要注意。
比如 “screw_ie8”等。</p></li><li><h3>Externals</h3><p>将一些常用的库和模块，比如react/angular/vue/rxjs/immutable等从bundle文件分离出来。
增添全局变量(比如window.React)，引入CDN公用库文件，如BootCDN等。</p></li><li><h3>CommonsChunk</h3><p><ul><li>单页应用: 生成类似app.js和vendor.js两个文件,由服务器本身提供加载，提升缓存效率；</li><li>多页应用: 不同路由的任意组合的分割重组。</li></ul></p></li><li><h3>Scope Hoisting</h3><p>new webpack.optimize.ModuleConcatenationPlugin()</p><p>在Webpack v3新引进的。使用简单，效果不错。</p></li><li><h3>Lazy load</h3><p>如果只用到某个库的一部分内容，就不需要讲整个源码都包含入bundle中。</p><p>相关工具如蚂蚁金服ant.design的<a target="_blank" href="https://github.com/ant-design/babel-plugin-import">babel-plugin-import</a>， 或者<a target="_blank" href="https://github.com/lodash/lodash-webpack-plugin">lodash-webpack-plugin</a>,以及lodash.xxx替代lodash的局部模块。</p></li><li><h3>devtool</h3><p>有文章建议cheap-module-source-map，但是production环境下Dev意义不大，直接devtool=false</p></li><li><h3>gzip/compression</h3><p> <a target="_blank" href="https://github.com/webpack-contrib/compression-webpack-plugin">compression-webpack-plugin</a>,<a target="_blank" href="https://github.com/expressjs/compression">expressjs/compression</a></p><p>文件压缩，非常重要，下文详细讲。</p></li></ol><h2>高级优化</h2><p>回到本文的开始的问题，答案就是<a target="_blank" href="https://en.wikipedia.org/wiki/HTTP_compression">HTTP压缩</a>。</p><h3>原理</h3><p>现代浏览器在进行http请求的时候，普遍支持gzip压缩。这种优化不限制于webpack生成的bundle文件，css、html和图片都可以采用类似策略。在发出请求的时候，
会在http头部显示Accept-Encoding:gzip, deflate
也就是告诉服务器可以接受这两种压缩格式。</p><p>于是服务器就可以把vue.js文件压缩，并设置Content-Encoding:gzip。浏览器看到这个头部设置，自动解压缩。这种压缩可以减少至少60%的体积。
所以两个vue.js文件的显示大小不一样，因为CDN对返回的脚本进行了压缩传输。</p><h3>实际操作</h3><ul><li><h3>express.js</h3><p>express.js项目中，如果使用app.use(express.static('xxx', [options]))，服务器会主动查看gzip请求，
将静态文件压缩并返回, 也可以手动设置option参数。
但是这种压缩并非一劳永逸的，每次请求都要消耗服务器内部的部分资源。优化方法可以是提前压缩再放入路径。</p><p>如果res.sendFile('vue.js')，默认是不压缩的。</p></li><li><h3>阿里云OSS，AWS的S3，或者CDN</h3><p>如果把静态文件部署在OSS/S3上，默认不压缩。但是可以进行返回包http头的<a target="_blank" href="https://help.aliyun.com/knowledge_detail/40136.html">手动设置</a>。</p></li></ul><br><p>通过以上各种方式的叠加组合，
基本可以将原来庞大的文件减少为1/10甚至1/20，加载时间大幅减少。如<a target="_blank" href="http://www.colorpk.com">ColorPK</a>:)</p><p>以上步骤其实相对机械化，逐步完成就能达到效果。
当然，在项目代码内部，优化变量作用域，提高模块化和复用率等，其实更有意义和价值。
这部分抽空我再写一篇文章。</p></article><div class="menubar"><div role="group" class="pure-button-group"><a title="Front End Framework" href="/" class="pure-button"><img src="//dkny.oss-cn-hangzhou.aliyuncs.com/1/assets/vue.png"/></a><a title="Node.js Framework" href="/node" class="pure-button"><img src="//dkny.oss-cn-hangzhou.aliyuncs.com/1/assets/mongo.png"/></a><a title="JS Library" href="/library" class="pure-button"><img src="//dkny.oss-cn-hangzhou.aliyuncs.com/1/assets/bower.png"/></a><a title="Tool" href="/site/" class="pure-button"><img src="//dkny.oss-cn-hangzhou.aliyuncs.com/1/assets/site.png"/></a><a title="Article" href="/article/" class="pure-button pure-button-active"><img src="//dkny.oss-cn-hangzhou.aliyuncs.com/1/assets/flight.png"/></a></div></div><footer><span>&copy; 2017 JavaScript.fun</span></footer></div></div></body>